env:
  IMAGE_TAG: 39
  GITHUB_SERVER_URL: "https://github.com"
  CIRRUS_SHELL: bash
  IMAGE_SUFFIX: "c20240227t125812z-f39f38d13"
  FEDORA_AARCH64_AMI: "fedora-podman-aws-arm64-${IMAGE_SUFFIX}"
  FEDORA_AMI: "fedora-aws-${IMAGE_SUFFIX}"


aws_credentials: ENCRYPTED[1625a7241b4d8c8b56fab6419ba3cd6969f44c854568d12166cb9a32688784c5cc4570d7e3d9c4f03d143e275a50b819]

build_task:
  alias: 'build'
  only_if: $CIRRUS_BRANCH == 'main' && $CIRRUS_PR == "" && $CIRRUS_TAG == ""
  # execution_lock: podman-wsl-fedora-arm-serial
  auto_cancellation: true
  env:
    matrix:
      - BUILD_ARCH: "arm64"
        USE_AMI: $FEDORA_AARCH64_AMI
        USE_TYPE: "t4g.large"
      - BUILD_ARCH: "amd64"
        USE_AMI: $FEDORA_AMI
        USE_TYPE: "t3.large"
    LAST_IMAGE_FILE: latest-$BUILD_ARCH
  name: "build-$BUILD_ARCH"
  ec2_instance:
    image: $USE_AMI
    type: $USE_TYPE
    region: us-east-1
    architecture: $BUILD_ARCH
  setup_script: |
    dnf install 'dnf-command(config-manager)'
    dnf config-manager --add-repo https://cli.github.com/packages/rpm/gh-cli.repo
    dnf -y install gh git podman golang
  get_script: |
    set +o verbose
    date >> changes
    podman image pull docker.io/library/fedora:$IMAGE_TAG
    imageDigest=`podman image inspect docker.io/library/fedora:$IMAGE_TAG --format {{.Digest}}`
    echo $imageDigest > "$LAST_IMAGE_FILE"
    echo "Fetching $GITHUB_SERVER_URL/$CIRRUS_REPO_FULL_NAME/releases/latest/download/$LAST_IMAGE_FILE"
    lastImage=`curl --retry 5 --retry-delay 8 --retry-all-errors -L "$GITHUB_SERVER_URL/$CIRRUS_REPO_FULL_NAME/releases/latest/download/$LAST_IMAGE_FILE"`
    echo "Digest: $imageDigest"
    echo "Last: $lastImage"
    if [ "$lastImage" != "$imageDigest" ]; then
      echo "Image needs update"
      echo -e "\nImage update:\n $imageDigest\n" >> changes
      echo "IMAGE_CHANGED=1" >> $CIRRUS_ENV
    fi
  reuse_script: |
    set +o verbose
    if [ "$IMAGE_CHANGED" == "1" ]; then
      echo "Skipped"
      exit
    fi
    echo "Reusing cached image"
    curl --retry 5 --retry-delay 8 --retry-all-errors -L $GITHUB_SERVER_URL/$CIRRUS_REPO_FULL_NAME/releases/latest/download/rootfs.tar.xz --output rootfs.tar.xz
    echo "Extracting rootfs.."
    unxz rootfs.tar.xz
    podman import rootfs.tar fedora-update
    podman create --name fedora-update fedora-update sleep 7200
  clean_script: |
    set +o verbose
    if [ "$IMAGE_CHANGED" != "1" ]; then
      echo "Skipped"
      exit
    fi
    echo "Using clean image"
    podman create --name fedora-update docker.io/library/fedora:$IMAGE_TAG sleep 7200
  update_script: |
    set +o verbose
    exit
    podman start fedora-update
    podman exec fedora-update sh -c 'rpm -qa --qf "%-30{name} %{version}-%{release}\n" | sort' > pre-update
    podman exec -it fedora-update sh -c 'dnf update -y && dnf -y install podman podman-docker procps-ng openssh-server net-tools iproute dhcp-client crun-wasm wasmedge-rt && dnf clean all && rm -rf /var/cache/yum'
    podman exec fedora-update sh -c 'rpm -qa --qf "%-30{name} %{version}-%{release}\n" | sort' > post-update

    diff -u pre-update post-update > delta || delta=1
    if [ ! -z "$delta" ]; then
      echo "Package changes!"
      echo -e "\nInstalled packages:\n\`\`\`" >> changes
      grep '^+' delta | grep -v '+++' | sed 's/^\+//g' >> changes
      echo "\`\`\`" >> changes
      echo "PACKAGE_CHANGED=1" >> $CIRRUS_ENV
    fi
  archive_script: |
    set +o verbose
    if [ "$IMAGE_CHANGED" != "1" ] && [ "$PACKAGE_CHANGED" != "1" ]; then
      echo "Skipping archive, no updates required"
      exit
    fi
    echo "Creating rootfs.tar from container..."
    podman export --output rootfs.tar fedora-update
    # GNu tar has a corruption bugs with --delete, so use bsdtar to filter instead
    echo "Filtering rootfs.tar using container..."
    podman run -v .:/mnt --security-opt label=disable fedora sh -c 'dnf -y install bsdtar && bsdtar -cf /mnt/new.tar --exclude etc/resolv.conf @/mnt/rootfs.tar'
    mv new.tar rootfs.tar
    mkdir -p etc; touch etc/resolv.conf
    tar rf rootfs.tar --mode=644 --group=root --owner=root etc/resolv.conf
    echo "Compressing rootfs.tar.."
    xz --verbose rootfs.tar
    echo "Done"
    mv changes "changes-$BUILD_ARCH"
    mv rootfs.tar.xz "rootfs-$BUILD_ARCH.tar.xz"
    ls -lh rootfs*.tar.xz
    tar czvf upload.tar.gz rootfs*.tar.xz changes-* "$LAST_IMAGE_FILE"
    curl -X POST --data-binary @upload.tar.gz "http://$CIRRUS_HTTP_CACHE_HOST/upload-$BUILD_ARCH"


release_task:
  depends_on:
    - build
  ec2_instance:
    image: $FEDORA_AMI
    type: t3.large
    region: us-east-1
    architecture: amd64
  arm_cache:
    folder: ./upload-arm64
    fingerprint_key: upload-arm64
  intel_cache:
    folder: ./upload-amd64
    fingerprint_key: upload-amd64
  release_script: |
    set +o verbose
    mkdir -p upload-amd64 upload-arm64

    HTTP_PREFIX="$GITHUB_SERVER_URL/$CIRRUS_REPO_FULL_NAME/releases/latest/download"
    if [ ! -f ./upload-amd64/rootfs-amd64.tar.gz  ]; then
      NO_INTEL=1
      FETCH1="$HTTP_PREFIX/rootfs-amd64.tar.xz"
      FETCH2="$HTTP_PREFIX/latest-amd64"
      echo "none\n" >> ./changes-amd64
    fi

    if [ ! -f ./upload-amd64/rootfs-arm64.tar.gz  ]; then
      NO_ARM=1
      FETCH1="$HTTP_PREFIX/rootfs-arm64.tar.xz"
      FETCH2="$HTTP_PREFIX/latest-arm64"
      echo "none\n" >> ./changes-arm64
    fi

    if [ "$NO_INTEL" == "1" && "$NO_ARM" == "1"]; then
      echo "Nothing to do."
    fi

    mv upload-amd64/* upload-arm64/* .
    test -z $FETCH1 || curl --retry 5 --retry-delay 8 --retry-all-errors -LO "$FETCH1"
    test -z $FETCH2 || curl --retry 5 --retry-delay 8 --retry-all-errors -LO "$FETCH2"
    
    echo "amd64 changes:\n " >> changes
    cat ./changes-amd64 >> changes

    echo "arm64 changes:\n " >> changes
    cat ./changes-arm64 >> changes
    
    git fetch --tags
    set +o pipefail
    NEXT_RELEASE=`git tag --list | grep v${IMAGE_TAG} | cut -f3 -d '.' | sort -n | tail -1`
    re='^[0-9]+$'
    if ! [[ $NEXT_RELEASE =~ $re ]] ; then
      NEXT_RELEASE=0
    fi
    NEXT_RELEASE="v${IMAGE_TAG}.0.$((NEXT_RELEASE+1))"
    echo $NEXT_RELEASE > version
    echo "Releasing $NEXT_RELEASE"
    sha256sum rootfs*.tar.xz > shasums
    set -o verbose
    gh release create $NEXT_RELEASE -t $NEXT_RELEASE -d -F changes
    gh release upload $NEXT_RELEASE lastimage* rootfs*.tar.xz shasums version
    gh release edit $NEXT_RELEASE --draft=false
